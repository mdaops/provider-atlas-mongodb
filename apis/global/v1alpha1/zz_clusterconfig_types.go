// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ClusterConfigInitParameters struct {

	// The name of the Global Cluster.
	ClusterName *string `json:"clusterName,omitempty" tf:"cluster_name,omitempty"`

	// Each element in the list maps one ISO location code to a zone in your Global Cluster. See Custom Zone Mapping below for more details.
	CustomZoneMappings []CustomZoneMappingsInitParameters `json:"customZoneMappings,omitempty" tf:"custom_zone_mappings,omitempty"`

	// Add a managed namespaces to a Global Cluster. For more information about managed namespaces, see Global Clusters. See Managed Namespace below for more details.
	ManagedNamespaces []ManagedNamespacesInitParameters `json:"managedNamespaces,omitempty" tf:"managed_namespaces,omitempty"`

	// The unique ID for the project to create the database user.
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`
}

type ClusterConfigObservation struct {

	// The name of the Global Cluster.
	ClusterName *string `json:"clusterName,omitempty" tf:"cluster_name,omitempty"`

	// (Deprecated) A map of all custom zone mappings defined for the Global Cluster to replication_specs.*.id. This attribute is deprecated, use custom_zone_mapping_zone_id instead.
	// +mapType=granular
	CustomZoneMapping map[string]*string `json:"customZoneMapping,omitempty" tf:"custom_zone_mapping,omitempty"`

	// A map of all custom zone mappings defined for the Global Cluster to replication_specs.*.zone_id. Atlas automatically maps each location code to the closest geographical zone. Custom zone mappings allow administrators to override these automatic mappings. If your Global Cluster does not have any custom zone mappings, this document is empty.
	// +mapType=granular
	CustomZoneMappingZoneID map[string]*string `json:"customZoneMappingZoneId,omitempty" tf:"custom_zone_mapping_zone_id,omitempty"`

	// Each element in the list maps one ISO location code to a zone in your Global Cluster. See Custom Zone Mapping below for more details.
	CustomZoneMappings []CustomZoneMappingsObservation `json:"customZoneMappings,omitempty" tf:"custom_zone_mappings,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Add a managed namespaces to a Global Cluster. For more information about managed namespaces, see Global Clusters. See Managed Namespace below for more details.
	ManagedNamespaces []ManagedNamespacesObservation `json:"managedNamespaces,omitempty" tf:"managed_namespaces,omitempty"`

	// The unique ID for the project to create the database user.
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`
}

type ClusterConfigParameters struct {

	// The name of the Global Cluster.
	// +kubebuilder:validation:Optional
	ClusterName *string `json:"clusterName,omitempty" tf:"cluster_name,omitempty"`

	// Each element in the list maps one ISO location code to a zone in your Global Cluster. See Custom Zone Mapping below for more details.
	// +kubebuilder:validation:Optional
	CustomZoneMappings []CustomZoneMappingsParameters `json:"customZoneMappings,omitempty" tf:"custom_zone_mappings,omitempty"`

	// Add a managed namespaces to a Global Cluster. For more information about managed namespaces, see Global Clusters. See Managed Namespace below for more details.
	// +kubebuilder:validation:Optional
	ManagedNamespaces []ManagedNamespacesParameters `json:"managedNamespaces,omitempty" tf:"managed_namespaces,omitempty"`

	// The unique ID for the project to create the database user.
	// +kubebuilder:validation:Optional
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`
}

type CustomZoneMappingsInitParameters struct {

	// The ISO location code to which you want to map a zone in your Global Cluster. You can find a list of all supported location codes here.
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// The name of the zone in your Global Cluster that you want to map to location.
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type CustomZoneMappingsObservation struct {

	// The ISO location code to which you want to map a zone in your Global Cluster. You can find a list of all supported location codes here.
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// The name of the zone in your Global Cluster that you want to map to location.
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type CustomZoneMappingsParameters struct {

	// The ISO location code to which you want to map a zone in your Global Cluster. You can find a list of all supported location codes here.
	// +kubebuilder:validation:Optional
	Location *string `json:"location,omitempty" tf:"location,omitempty"`

	// The name of the zone in your Global Cluster that you want to map to location.
	// +kubebuilder:validation:Optional
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type ManagedNamespacesInitParameters struct {

	// The name of the collection associated with the managed namespace.
	Collection *string `json:"collection,omitempty" tf:"collection,omitempty"`

	// The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
	CustomShardKey *string `json:"customShardKey,omitempty" tf:"custom_shard_key,omitempty"`

	// The name of the database containing the collection.
	DB *string `json:"db,omitempty" tf:"db,omitempty"`

	// Specifies whether the custom shard key for the collection is hashed. If omitted, defaults to false. If false, Atlas uses ranged sharding. This is only available for Atlas clusters with MongoDB v4.4 and later.
	IsCustomShardKeyHashed *bool `json:"isCustomShardKeyHashed,omitempty" tf:"is_custom_shard_key_hashed,omitempty"`

	// Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using hashed shard keys.
	IsShardKeyUnique *bool `json:"isShardKeyUnique,omitempty" tf:"is_shard_key_unique,omitempty"`
}

type ManagedNamespacesObservation struct {

	// The name of the collection associated with the managed namespace.
	Collection *string `json:"collection,omitempty" tf:"collection,omitempty"`

	// The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
	CustomShardKey *string `json:"customShardKey,omitempty" tf:"custom_shard_key,omitempty"`

	// The name of the database containing the collection.
	DB *string `json:"db,omitempty" tf:"db,omitempty"`

	// Specifies whether the custom shard key for the collection is hashed. If omitted, defaults to false. If false, Atlas uses ranged sharding. This is only available for Atlas clusters with MongoDB v4.4 and later.
	IsCustomShardKeyHashed *bool `json:"isCustomShardKeyHashed,omitempty" tf:"is_custom_shard_key_hashed,omitempty"`

	// Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using hashed shard keys.
	IsShardKeyUnique *bool `json:"isShardKeyUnique,omitempty" tf:"is_shard_key_unique,omitempty"`
}

type ManagedNamespacesParameters struct {

	// The name of the collection associated with the managed namespace.
	// +kubebuilder:validation:Optional
	Collection *string `json:"collection" tf:"collection,omitempty"`

	// The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
	// +kubebuilder:validation:Optional
	CustomShardKey *string `json:"customShardKey" tf:"custom_shard_key,omitempty"`

	// The name of the database containing the collection.
	// +kubebuilder:validation:Optional
	DB *string `json:"db" tf:"db,omitempty"`

	// Specifies whether the custom shard key for the collection is hashed. If omitted, defaults to false. If false, Atlas uses ranged sharding. This is only available for Atlas clusters with MongoDB v4.4 and later.
	// +kubebuilder:validation:Optional
	IsCustomShardKeyHashed *bool `json:"isCustomShardKeyHashed,omitempty" tf:"is_custom_shard_key_hashed,omitempty"`

	// Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using hashed shard keys.
	// +kubebuilder:validation:Optional
	IsShardKeyUnique *bool `json:"isShardKeyUnique,omitempty" tf:"is_shard_key_unique,omitempty"`
}

// ClusterConfigSpec defines the desired state of ClusterConfig
type ClusterConfigSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ClusterConfigParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ClusterConfigInitParameters `json:"initProvider,omitempty"`
}

// ClusterConfigStatus defines the observed state of ClusterConfig.
type ClusterConfigStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ClusterConfigObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// ClusterConfig is the Schema for the ClusterConfigs API.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,atlas-mongodb}
type ClusterConfig struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.clusterName) || (has(self.initProvider) && has(self.initProvider.clusterName))",message="spec.forProvider.clusterName is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.projectId) || (has(self.initProvider) && has(self.initProvider.projectId))",message="spec.forProvider.projectId is a required parameter"
	Spec   ClusterConfigSpec   `json:"spec"`
	Status ClusterConfigStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ClusterConfigList contains a list of ClusterConfigs
type ClusterConfigList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ClusterConfig `json:"items"`
}

// Repository type metadata.
var (
	ClusterConfig_Kind             = "ClusterConfig"
	ClusterConfig_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ClusterConfig_Kind}.String()
	ClusterConfig_KindAPIVersion   = ClusterConfig_Kind + "." + CRDGroupVersion.String()
	ClusterConfig_GroupVersionKind = CRDGroupVersion.WithKind(ClusterConfig_Kind)
)

func init() {
	SchemeBuilder.Register(&ClusterConfig{}, &ClusterConfigList{})
}
